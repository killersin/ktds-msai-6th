# Azure AI Search의 의미론적 순위 지정 완벽 가이드

Azure AI Search의 **의미론적 순위 지정(Semantic Ranking)**은 Microsoft의 고급 언어 이해 모델을 활용하여 검색 결과의 관련성을 크게 향상시키는 프리미엄 기능입니다. 이 기능이 어떻게 작동하고 어떤 이점을 제공하는지 자세히 알아보겠습니다.[1][2]

## 의미론적 순위 지정이란?

### 핵심 개념
의미론적 순위 지정은 단순한 키워드 매칭을 넘어 **쿼리의 맥락과 의미**를 이해하여 검색 결과를 재정렬하는 기술입니다. 예를 들어, "capital"이라는 단어가 금융, 법률, 지리학, 문법 등 다양한 맥락에서 다른 의미를 갖는다는 것을 이해하고, 쿼리의 의도에 맞는 결과를 상위에 배치합니다.[3][1]

### 기존 검색과의 차이점
- **기존 BM25 검색**: 검색어가 문서 내에 얼마나 자주 나타나는지에 기반하여 순위 결정[4][5]
- **의미론적 검색**: 언어의 맥락과 의미를 이해하여 더 관련성 높은 결과 제공[4][1]

## 의미론적 순위 지정의 작동 원리

### 3단계 처리 과정

#### 1단계: 입력 수집 및 요약
- 기존 BM25 또는 RRF 순위에서 **상위 50개 결과**를 선택합니다[1][4]
- 결과를 의미론적 구성에 정의된 여러 필드로 분할합니다[4]
- 각 필드는 텍스트 문자열로 변환되고 **256개의 고유 토큰**으로 제한됩니다[4]

#### 2단계: 의미론적 점수 계산
- Microsoft의 기계 독해 모델이 쿼리와 가장 잘 일치하는 구문과 문장을 찾습니다[4]
- 원래 BM25 점수와 언어 이해 모델의 결과를 결합하여 새로운 관련성 점수를 계산합니다[4]

#### 3단계: 결과 출력
- 의미론적 관련성에 따라 재정렬된 결과를 반환합니다[4]
- **의미론적 캡션**과 **의미론적 답변**(선택사항)을 함께 제공합니다[1]

## 의미론적 검색의 3가지 주요 기능

### 1. L2 (Level 2) 재순위 지정
기존 검색 결과에 대해 **2차 순위 지정**을 적용하여 의미적으로 더 관련성 높은 결과를 상위로 이동시킵니다.[6][1]

### 2. 의미론적 캡션 (Semantic Captions)
- 검색 결과에서 **가장 관련성 높은 문장과 구문을 추출**하여 요약 제공[1]
- 핵심 구문에 **하이라이트** 적용으로 사용자의 스캔 효율성 향상[7][4]
- 개별 콘텐츠 필드가 검색 결과 페이지에 표시하기에 너무 길 때 유용[1]

### 3. 의미론적 답변 (Semantic Answers)
- **질문 형태의 쿼리**에 대해 직접적인 답변을 제공하는 선택적 기능[7][1]
- 문서에서 답변의 특성을 가진 텍스트를 **그대로 추출**하여 반환[7]
- 생성형 AI가 아닌 **기존 콘텐츠에서 추출**하는 방식[7]

## 의미론적 구성(Semantic Configuration) 설정

### 필수 구성 요소

#### 1. 제목 필드 (Title Field)
- **25단어 미만**의 짧은 문자열 권장[6]
- 문서 제목, 제품명, 고유 식별자 등에 사용[6]
- 하나의 필드만 지정 가능[6]

#### 2. 콘텐츠 필드 (Content Fields)
- **자연어 형태의 긴 텍스트** 청크[6]
- 문서 본문, 제품 설명, 자유 형식 텍스트 등[6]
- 여러 필드 지정 가능하며 **우선순위 순서**로 나열[6]

#### 3. 키워드 필드 (Keywords Fields)
- 문서의 태그나 카테고리 같은 **키워드 목록**[6]
- 항목의 설명적 용어 등[6]
- 여러 필드 지정 가능[6]

### 설정 예제

#### REST API를 통한 구성
```json
"semantic": {
  "defaultConfiguration": "my-semantic-config",
  "configurations": [
    {
      "name": "my-semantic-config",
      "prioritizedFields": {
        "titleField": {
          "fieldName": "HotelName"
        },
        "prioritizedContentFields": [
          {
            "fieldName": "Description"
          }
        ],
        "prioritizedKeywordsFields": [
          {
            "fieldName": "Tags"
          }
        ]
      }
    }
  ]
}
```

#### .NET SDK를 통한 구성
```csharp
SemanticSearch = new()
{
    Configurations =
    {
        new SemanticConfiguration("my-semantic-config", new()
        {
            TitleField = new SemanticField("HotelName"),
            ContentFields =
            {
                new SemanticField("Description")
            },
            KeywordsFields =
            {
                new SemanticField("Category")
            }
        })
    }
}
```

## 의미론적 검색 쿼리 실행

### 기본 쿼리 구조
```json
{
    "search": "what hotel has a good restaurant on site",
    "queryType": "semantic",
    "semanticConfigurationName": "my-semantic-config",
    "queryLanguage": "en-us",
    "queryCaption": "extractive",
    "queryCaptionHighlightEnabled": true
}
```

### C# SDK를 통한 구현
```csharp
SearchOptions searchOptions = new SearchOptions()
{
    QueryType = SearchQueryType.Semantic,
    SemanticConfigurationName = "my-semantic-config",
    QueryCaption = QueryCaptionType.Extractive,
    QueryCaptionHighlightEnabled = true,
};

SearchResults<Hotel> searchResults = searchClient.Search<Hotel>(
    "what hotel has a good restaurant on site", 
    searchOptions
);
```

## 의미론적 답변 구현

### 답변 요청 설정
```json
{
    "search": "how do clouds form",
    "queryType": "semantic",
    "queryLanguage": "en-us",
    "semanticConfiguration": "my-semantic-config",
    "answers": "extractive|count-3",
    "captions": "extractive|highlight-true"
}
```

### 답변 응답 구조
```json
{
    "@search.answers": [
        {
            "key": "4123",
            "text": "구름이 형성되는 과정에 대한 설명...",
            "highlights": "강조 표시된 텍스트...",
            "score": 0.94639826
        }
    ],
    "value": [
        // 일반 검색 결과들
    ]
}
```

## 장점과 제한사항

### 주요 장점
1. **향상된 관련성**: 쿼리의 의미와 더 가깝게 일치하는 결과 제공[4]
2. **풍부한 정보**: 캡션과 답변을 통한 추가적인 컨텍스트 제공[4]
3. **사용자 경험 개선**: 하이라이트된 핵심 구문으로 빠른 정보 파악 가능[1]

### 제한사항
1. **기존 결과 기반**: BM25에서 반환된 결과만 재순위 가능, 새로운 문서 발견 불가[1][4]
2. **상위 50개 제한**: 50개 이상의 결과가 있어도 상위 50개만 처리[4]
3. **콘텐츠 의존성**: 정보가 풍부하고 산문 형태의 콘텐츠에서 최적 성능[1]

## 가격 및 사용량 관리

### 가격 구조
- **기본 서비스 요금**: 검색 서비스 자체의 고정 비용
- **의미론적 순위 지정**: `queryType=semantic`인 쿼리 수에 따른 **누진 요금제**[8][9]
- 사용하지 않으면 요금이 발생하지 않는 **사용량 기반 과금**[8]

### 지원 요구사항
- **Basic 티어 이상**의 검색 서비스 필요[6]
- **특정 지역**에서만 사용 가능[4]
- 의미론적 순위 지정이 **활성화**된 서비스 필요[6]

## 실제 활용 시나리오

### 적합한 콘텐츠 유형
- **지식 베이스**: FAQ, 기술 문서[1]
- **온라인 문서**: 설명서, 가이드[1]
- **설명적 콘텐츠**: 제품 상세 정보, 뉴스 기사[1]

### 최적화 팁
1. **필드 우선순위**: 콘텐츠와 키워드 필드를 중요도 순으로 배열[6]
2. **질문 형태 쿼리**: "what", "where", "when", "how"로 시작하는 쿼리에서 최적 성능[7]
3. **하이브리드 검색**: 벡터 검색과 결합하여 더 나은 결과 달성[10]

## 쿼리 재작성 (Query Rewrite) 기능

의미론적 순위 지정은 추가적으로 **쿼리 재작성** 기능을 제공합니다:[1]
- 원본 쿼리를 **최대 10개의 변형**으로 확장
- **오타 수정**이나 **동의어 생성**을 통한 쿼리 개선
- 재작성된 쿼리로 검색 엔진 실행 후 의미론적 재순위 적용

의미론적 순위 지정은 Azure AI Search에서 검색 품질을 획기적으로 개선할 수 있는 강력한 도구입니다. 특히 자연어 질의응답이나 복잡한 정보 검색이 필요한 애플리케이션에서 사용자 경험을 크게 향상시킬 수 있습니다.[4][1]

---
### 참고자료 RRF 순위
---

### RRF(Reciprocal Rank Fusion) 순위 지정 정리

**Reciprocal Rank Fusion(RRF)**는 여러 개의 검색 결과 집합을 하나로 결합하면서, 각 문서가 원래 결과 리스트에서 차지한 위치(rank)에 기반해 점수를 부여하고 최종 순위를 결정하는 알고리즘입니다.[1][2]

## 1. RRF의 기본 개념  
- **복수의 쿼리 실행**: 하이브리드 검색에서는 키워드 검색, 벡터 검색, 의미론적 순위 지정 등 **서로 다른 방법으로 동시에** 쿼리를 실행합니다.  
- **서로 다른 결과 집합**: 각 쿼리는 독립적으로 순위가 매겨진 문서 리스트(Top N)를 반환합니다.  
- **상호 순위(Reciprocal Rank)**: 문서 d가 리스트에서 rank 위치에 있을 때 상호 순위 점수는 $$ \frac{1}{\text{rank} + k} $$로 계산됩니다.  
  - 여기서 $$k$$는 경험적으로 **60** 정도가 권장되는 작은 상수입니다.[1]

## 2. RRF 순위 지정 프로세스  
1. **결과 수집**: 병렬로 실행된 각 쿼리에서 상위 문서(기본값은 Top 50)를 가져옵니다.[1]
2. **상호 순위 점수 계산**:  
   $$
     \text{RRScore}_{q,d} = \frac{1}{\text{rank}_{q,d} + k}
   $$
   - $$\text{rank}_{q,d}$$: 쿼리 $$q$$ 결과 리스트에서 문서 $$d$$의 위치(1부터 시작)  
   - $$k$$: 순위 상수를 의미하며, BM25나 벡터 이웃 개수를 제어하는 k와는 별개입니다.[1]
3. **점수 결합**: 모든 쿼리에 대해 계산된 상호 순위 점수를 **합산**하여 문서별 최종 RRF 점수를 얻습니다.  
   $$
     \text{RRFScore}_d = \sum_{q} \text{RRScore}_{q,d}
   $$
4. **최종 정렬**: 결합된 점수에 따라 문서들을 내림차순으로 정렬하여 단일 결과 집합을 반환합니다.[2]

## 3. 하이브리드 검색에서의 활용  
- **키워드 + 벡터 검색**: 전통적인 BM25 검색과 벡터 검색을 병합해 강점이 다른 두 방식을 보완합니다.  
- **다중 벡터 필드**: 벡터 필드를 여러 개 지정한 쿼리도 각각 병렬 실행 후 RRF로 합칩니다.  
- **가중치 부여**: REST API의 프리뷰 버전에서는 RRF 점수 컴포넌트를 분해해 각 서브쿼리의 기여를 확인할 수 있습니다.[1]

## 4. 주요 장점  
- **튜닝 불필요**: 단일 가중치나 복잡한 파라미터 설정 없이도 여러 검색 방식을 효과적으로 결합할 수 있습니다.[1]
- **강건성 향상**: 한 방식이 놓친 관련 문서를 다른 방식이 보완하면서 전반적인 관련성이 개선됩니다.  
- **간단한 수학**: $$\tfrac{1}{\text{rank}+k}$$ 계산과 덧셈만으로 구현 난이도가 낮습니다.  

## 5. 고려사항  
- **Top N 한계**: 각 쿼리에서 기본적으로 상위 50개만 처리하므로, 그 이후 순위는 반영되지 않습니다.  
- **k 값 선택**: $$k$$ 값이 너무 크면 모든 문서 점수가 작아져 순위 구분이 어려워질 수 있고, 너무 작으면 상위 문서에 과도한 점수를 부여하게 됩니다.  
- **패러렐 실행 비용**: 여러 쿼리를 병렬 실행하므로 쿼리당 처리 비용과 지연 시간이 증가할 수 있습니다.  

Reciprocal Rank Fusion은 Azure AI Search의 하이브리드 검색 핵심 알고리즘으로, 키워드 검색·벡터 검색·의미론적 순위 지정 등 서로 다른 기법의 결과를 효율적으로 결합하여 **검색 정확도와 다양성**을 함께 확보할 수 있게 해줍니다.

[1](https://learn.microsoft.com/en-us/azure/search/hybrid-search-ranking)
[2](https://learn.microsoft.com/ko-kr/azure/search/hybrid-search-ranking)
[3](https://sammydeprez.github.io/blog/2024/07/05/reciprocal-rank-fusion-rrf.html)
[4](https://www.elastic.co/docs/reference/elasticsearch/rest-apis/reciprocal-rank-fusion)
[5](https://www.meilisearch.com/blog/fixing-hybrid-search)
[6](https://docs.azure.cn/en-us/search/hybrid-search-how-to-query)
[7](https://learn.microsoft.com/ko-kr/azure/search/hybrid-search-how-to-query)
[8](https://learn.microsoft.com/ko-kr/azure/search/hybrid-search-overview)
[9](https://julie-tech.tistory.com/144)

[1](https://learn.microsoft.com/en-us/azure/search/semantic-search-overview)
[2](https://learn.microsoft.com/ko-kr/azure/search/semantic-search-overview)
[3](https://www.youtube.com/watch?v=TvpMwvP5Fug)
[4](https://dev.to/willvelida/improving-azure-ai-search-results-with-semantic-search-1mpk)
[5](https://learn.microsoft.com/en-us/azure/search/index-similarity-and-scoring)
[6](https://learn.microsoft.com/en-us/azure/search/semantic-how-to-configure)
[7](https://learn.microsoft.com/en-us/azure/search/semantic-answers)
[8](https://docs.azure.cn/en-us/search/search-sku-manage-costs)
[9](https://azure.microsoft.com/en-us/pricing/details/search/)
[10](https://techcommunity.microsoft.com/blog/azure-ai-foundry-blog/azure-ai-search-outperforming-vector-search-with-hybrid-retrieval-and-reranking/3929167)
[11](https://learn.microsoft.com/ko-kr/azure/search/semantic-how-to-query-request)
[12](https://stackoverflow.com/questions/77748237/purpose-of-content-title-and-keyword-in-semantic-ranking)
[13](https://docs.azure.cn/en-us/search/semantic-search-overview)
[14](https://docs.azure.cn/en-us/search/search-what-is-azure-search)
[15](https://github.com/langchain-ai/langchain/issues/20549)
[16](https://learn.microsoft.com/en-gb/answers/questions/1642485/choosing-between-keyword-search-vector-search-keyw)
[17](https://www.youtube.com/watch?v=Xwx1DJ0OqCk)
[18](https://learn.microsoft.com/en-us/azure/search/search-get-started-semantic)
[19](https://docs.azure.cn/en-us/search/semantic-how-to-query-request)
[20](https://www.youtube.com/watch?v=Ye6zGMikC2U)
[21](https://learn.microsoft.com/ko-kr/azure/search/search-get-started-semantic)
[22](https://docs.azure.cn/en-us/search/semantic-how-to-enable-disable)
[23](https://www.reddit.com/r/AZURE/comments/1fud706/semantic_answers_not_showing_up_in_my_azure_ai/)
[24](https://learn.microsoft.com/ko-kr/azure/search/semantic-answers)
[25](https://stackoverflow.com/questions/77755643/cant-see-difference-in-the-three-searches-full-text-semantic-and-vector-sear)
[26](https://azure.microsoft.com/ko-kr/pricing/details/search/)
[27](https://learn.microsoft.com/en-us/azure/search/search-relevance-overview)
[28](https://docs.azure.cn/en-us/search/semantic-how-to-enable-scoring-profiles)
[29](https://docs.azure.cn/en-us/search/semantic-how-to-configure)
[30](https://docs.azure.cn/en-us/search/search-pagination-page-layout)
[31](https://learn.microsoft.com/en-us/answers/questions/1490180/vector-search-pricing-in-azure-ai-search)
[32](https://learn.microsoft.com/en-us/shows/ai-show/azure-ai-search-generating-the-right-answers-every-time)