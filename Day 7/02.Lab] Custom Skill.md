# Azure AI Search용 맞춤 스킬 만들기

Azure AI Search는 문서에서 AI가 생성한 필드를 추출해 검색 인덱스에 포함시키기 위해 AI 스킬 기반의 엔리치먼트 파이프라인(enrichment pipeline)을 사용합니다. 기본적으로 여러 내장 스킬이 제공되는데, 특정 요구사항을 충족하지 못한다면 **맞춤(custom) 스킬**을 만들 수 있습니다.

이 실습에서는 문서에서 사용된 단어의 빈도수를 집계해 **상위 5개 단어 목록**을 생성하는 맞춤 스킬을 만들고, 이를 가상의 여행사 Margie’s Travel 검색 솔루션에 추가합니다.

---

## Visual Studio Code에서 앱 개발 준비

앱은 Visual Studio Code에서 개발합니다. 코드 파일은 GitHub 저장소에 제공되어 있습니다.

> **팁(Tip):** 이미 `mslearn-knowledge-mining` 저장소를 클론했다면 Visual Studio Code에서 열어주세요. 그렇지 않다면 아래 절차에 따라 클론하세요.

1. Visual Studio Code 실행
2. 팔레트 열기 (SHIFT+CTRL+P) → `Git: Clone` 실행 → `https://github.com/MicrosoftLearning/mslearn-knowledge-mining` 저장소 클론
3. 클론된 폴더를 Visual Studio Code에서 열기
4. C# 프로젝트 빌드/디버그 지원 파일이 자동 설치될 때까지 대기

> **참고(Note):** "필요한 자산을 추가하시겠습니까?"라는 메시지가 나타나면 **Not Now** 선택.

---

## Azure 리소스 생성

> **Note:** 이전에 **Create an Azure AI Search solution** 실습을 완료하고 리소스가 남아 있다면 이 절차는 건너뛰고 **검색 솔루션 생성** 단계부터 시작하세요.

1. 웹 브라우저에서 Azure 포털(`https://portal.azure.com`) 접속 → Azure 계정으로 로그인
2. 상단 검색창에서 "Azure AI services" 검색 → **Azure AI services multi-service account** 생성
   - 구독(Subscription): 본인 Azure 구독
   - 리소스 그룹(Resource group): 기존 또는 새로 생성 (제한된 구독일 경우 제한된 그룹 사용)
   - 지역(Region): 본인 위치와 지리적으로 가까운 지역
   - 이름(Name): 고유한 이름
   - 가격 수준(Pricing tier): Standard S0
3. 리소스 생성 완료 후, 리소스의 **개요(Overview)** 페이지에서 **구독 ID(Subscription ID)**와 **지역(Location)** 기록
4. Visual Studio Code에서 `Labfiles/02-search-skill` 폴더 확장 → `setup.cmd` 선택
5. 해당 폴더에서 터미널 열기 (Right-click → **Open in Integrated Terminal**)
6. 터미널에서 로그인 명령 실행:
    ```bash
    az login --output none
    ````
7. 프롬프트가 뜨면 Azure 계정 선택 또는 로그인 → 로그인 완료될 때까지 대기
8. 다음 명령 실행:

   ```bash
   az account list-locations -o table
   ```
9. 리소스 그룹의 지역에 해당하는 "Name" 값을 확인 (예: East US → `eastus`)
10. `setup.cmd` 스크립트 내 `subscription_id`, `resource_group`, `location` 변수에 올바른 값 입력 → 저장
11. 터미널에서 스크립트 실행:

    ```bash
    ./setup
    ```
12. 완료되면 출력 내용에서 다음 정보 기록:

    * Storage account name
    * Storage connection string
    * Search service endpoint
    * Search service admin key
    * Search service query key
13. Azure 포털에서 리소스 그룹 새로 고침(Refresh) → 스토리지 계정, Azure AI Services, Azure AI Search 리소스 존재 확인

---

## 검색 솔루션 생성

필요한 Azure 리소스가 준비되었으므로, 다음 구성 요소로 검색 솔루션을 생성합니다:

* 데이터 소스(Data source): Azure Storage 컨테이너의 문서 참조
* 스킬셋(Skillset): 문서로부터 AI 생성 필드를 추출하는 스킬 파이프라인 정의
* 인덱스(Index): 검색 가능한 문서 레코드의 집합 정의
* 인덱서(Indexer): 데이터 소스에서 문서를 추출, 스킬셋 적용 후 인덱스에 전송

이 실습에서는 **Azure AI Search REST API**에 JSON 요청을 보내 구성 요소를 만듭니다.

1. `02-search-skill/create-search` 폴더에서 `data_source.json` 열기 → `YOUR_CONNECTION_STRING`를 본인의 Azure Storage 연결 문자열로 대체 → 저장
2. `skillset.json` 열기 → `cognitiveServices` 요소 내 `YOUR_AI_SERVICES_KEY`를 본인의 AI Services 키로 대체 → 저장
3. `index.json` 열기 → 검토 후 닫기 (변경 없음)
4. `indexer.json` 열기 → 검토 후 닫기 (변경 없음)
5. `create-search.cmd` 열기 → `YOUR_SEARCH_URL`, `YOUR_ADMIN_KEY` 변수 값을 본인의 Azure AI Search URL 및 관리 키로 대체 → 저장
6. `create-search` 폴더에서 터미널 열기 → 다음 실행:

   ```bash
   ./create-search
   ```
7. 완료되면 Azure 포털에서 **검색 서비스 리소스** → **Indexers** 페이지 선택 → 인덱싱 완료될 때까지 대기/새로 고침

---

## 인덱스 검색

인덱스 생성 후에는 검색을 테스트할 수 있습니다.

1. Azure AI Search 리소스 페이지 상단의 **Search explorer** 선택
2. \*\*쿼리 문자열(Query string)\*\*에 다음 입력 후 검색 실행:

   ```
   search=London&$select=url,sentiment,keyphrases&$filter=metadata_author eq 'Reviewer' and sentiment eq 'positive'
   ```

   → London이 언급된 문서 중 작성자가 Reviewer이고 긍정(sentiment)인 문서의 url, sentiment, keyphrases 조회

---

## 맞춤 스킬을 위한 Azure Function 만들기

기본 스킬 외에, 문서 내 자주 사용되는 단어를 식별하는 맞춤 스킬을 추가할 수 있습니다. 이 실습에서는 **Azure Portal** 내 Node.js 기반 **HTTP Trigger 함수**를 사용합니다.

1. Azure Portal 홈에서 **Function App** 리소스 생성:

   * Hosting Plan: Consumption
   * Subscription: 본인 구독
   * Resource Group: 기존 AI Search 리소스와 동일
   * Function App 이름: 고유한 이름
   * Runtime stack: Node.js
   * Version: 20 LTS
   * Region: AI Search 리소스와 동일 (만약 할당량 이슈 시 다른 region 가능)
   * OS: Windows
2. 배포 완료 후 해당 Function App 리소스로 이동 → **Create function** 클릭 → **HTTP Trigger** 템플릿 선택:

   * Function name: `wordcount`
   * Authorization level: Function
3. 함수가 생성되면 **Code + Test** 탭으로 이동 → 기본 코드를 아래 코드로 교체:

   ```js
   module.exports = async function (context, req) {
    context.log('JavaScript HTTP trigger function processed a request.');

    if (req.body && req.body.values) {

        vals = req.body.values;

        // Array of stop words to be ignored
        var stopwords = ['', 'i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', 
        "youre", "youve", "youll", "youd", 'your', 'yours', 'yourself', 
        'yourselves', 'he', 'him', 'his', 'himself', 'she', "shes", 'her', 
        'hers', 'herself', 'it', "its", 'itself', 'they', 'them', 
        'their', 'theirs', 'themselves', 'what', 'which', 'who', 'whom', 
        'this', 'that', "thatll", 'these', 'those', 'am', 'is', 'are', 'was',
        'were', 'be', 'been', 'being', 'have', 'has', 'had', 'having', 'do', 
        'does', 'did', 'doing', 'a', 'an', 'the', 'and', 'but', 'if', 'or', 
        'because', 'as', 'until', 'while', 'of', 'at', 'by', 'for', 'with', 
        'about', 'against', 'between', 'into', 'through', 'during', 'before', 
        'after', 'above', 'below', 'to', 'from', 'up', 'down', 'in', 'out', 
        'on', 'off', 'over', 'under', 'again', 'further', 'then', 'once', 'here', 
        'there', 'when', 'where', 'why', 'how', 'all', 'any', 'both', 'each', 
        'few', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 
        'only', 'own', 'same', 'so', 'than', 'too', 'very', 'can', 'will',
        'just', "dont", 'should', "shouldve", 'now', "arent", "couldnt", 
        "didnt", "doesnt", "hadnt", "hasnt", "havent", "isnt", "mightnt", "mustnt",
        "neednt", "shant", "shouldnt", "wasnt", "werent", "wont", "wouldnt"];

        res = {"values":[]};

        for (rec in vals)
        {
            // Get the record ID and text for this input
            resVal = {recordId:vals[rec].recordId, data:{}};
            txt = vals[rec].data.text;

            // remove punctuation and numerals
            txt = txt.replace(/[^ A-Za-z_]/g,"").toLowerCase();

            // Get an array of words
            words = txt.split(" ")

            // count instances of non-stopwords
            wordCounts = {}
            for(var i = 0; i < words.length; ++i) {
                word = words[i];
                if (stopwords.includes(word) == false )
                {
                    if (wordCounts[word])
                    {
                        wordCounts[word] ++;
                    }
                    else
                    {
                        wordCounts[word] = 1;
                    }
                }
            }

            // Convert wordcounts to an array
            var topWords = [];
            for (var word in wordCounts) {
                topWords.push([word, wordCounts[word]]);
            }

            // Sort in descending order of count
            topWords.sort(function(a, b) {
                return b[1] - a[1];
            });

            // Get the first ten words from the first array dimension
            resVal.data.text = topWords.slice(0,9)
              .map(function(value,index) { return value[0]; });

            res.values[rec] = resVal;
        };

        context.res = {
            body: JSON.stringify(res),
            headers: {
            'Content-Type': 'application/json'
        }

        };
    }
    else {
        context.res = {
            status: 400,
            body: {"errors":[{"message": "Invalid input"}]},
            headers: {
            'Content-Type': 'application/json'
        }

        };
    }
};


```
4. 함수 저장 후 **Test/Run** 탭 열기 → 다음 JSON 입력:

   ```json
 {
     "values": [
         {
             "recordId": "a1",
             "data":
             {
             "text":  "Tiger, tiger burning bright in the darkness of the night.",
             "language": "en"
             }
         },
         {
             "recordId": "a2",
             "data":
             {
             "text":  "The rain in spain stays mainly in the plains! That's where you'll find the rain!",
             "language": "en"
             }
         }
     ]
 }
   ```
5. **Run** 클릭 → 반환된 HTTP 응답 확인: 문서별 상위 단어 리스트 반환
6. **Test/Run** 창 닫기 → `Get function URL` 클릭 → 기본 키의 URL 복사 (다음 단계에서 사용됨)

---

## 맞춤 스킬을 검색 솔루션에 추가

이제 만든 Azure Function을 검색 솔루션의 스킬셋에 포함하고, 결과를 인덱스 필드에 매핑합니다.

1. `02-search-skill/update-search` 폴더에서 `update-skillset.json` 열기 → `get-top-words` WebApiSkill 정의의 `uri` 값에 복사한 함수 URL(`YOUR-FUNCTION-APP-URL`) 입력
2. `cognitiveServices` 요소 내 `YOUR_AI_SERVICES_KEY`를 본인 키로 대체 → 저장
3. `update-index.json` 열기 → `top_words` 필드가 포함된 인덱스 정의 확인 → 닫기
4. `update-indexer.json` 열기 → `top_words` 필드 매핑 포함 확인 → 닫기
5. `update-search.cmd` 열기 → `YOUR_SEARCH_URL`, `YOUR_ADMIN_KEY` 본인 값 입력 → 저장
6. 해당 폴더에서 터미널 열기 → 다음 실행:

   ```bash
   ./update-search
   ```
7. 완료 후 Azure 포털에서 **Indexers** 페이지로 이동 → 인덱싱 완료될 때까지 대기/새로 고침

---

## 인덱스 검색 (확장된)

이제 `top_words` 필드를 포함하여 검색할 수 있습니다.

1. **Search explorer**로 이동 → JSON 뷰로 변경
2. 다음 JSON 쿼리 실행:

   ```json
   {
     "search": "Las Vegas",
     "select": "url,top_words"
   }
   ```

→ "Las Vegas"가 언급된 문서의 `url`과 `top_words` 필드 조회 가능

---

## 정리 (Clean-up)

실습이 끝난 후, 더 이상 필요 없는 리소스는 삭제하세요:

1. Azure 포털에서 **Resource groups** 선택
2. 사용하지 않을 리소스 그룹 선택 → **Delete resource group** 클릭

---

## 추가 자료

맞춤 스킬 생성에 대한 자세한 내용은 \[Azure AI Search documentation]을 참고하세요.
GitHub 코드 예제도 \[MicrosoftLearning/mslearn-knowledge-mining]에서 확인 가능합니다.